一.如何解决问题：

  （1）类的确定：

	HuffmanNode     ——霍夫曼结点类，可表示内节点与外部节点
	Huffman	        ——霍夫曼类，霍夫曼编码功能
	HuffmanDecoder  ——霍夫曼解码类，扩展自霍夫曼类，有霍夫曼解码功能

  （2）程序流程：

	1.编码：
		打开待编码文件
		记录所有256个字符的频率，存进数组中
		关闭待编码文件
		使用priority_queue来保存数组中频率非空的节点指针
		通过priority_queue构造huffman树
		递归huffman树计算编码并通过指针赋给相应字符
		重新打开待编码文件
		生成编码字符串
		关闭待编码文件
		打开输出文件
		输出编码总位数
		输出频率非空的映射对（unsigned char,Huffman-Code）
		将编码字符串的每一位转化为unsigned char中的位
		每8个写入输出文件一次，最后不足8个位的，则左移至最左，再写入
		关闭输出文件
	2.解码：
		打开待解码文件
		读取编码总位数
		读取映射对
		把映射关系存进数组
		读取所有已编码信息并转为字符串
		关闭待解码文件
		扫描数组的Huffman-Code对字符串进行译码
		打开空译码文件	
		输出到译码文件
、		关闭译码文件

二.如何测试：
	1.通过样例测试，验证huffman编码的正确性；
	2.通过输出读取译码信息转化的字符串与编码字符串进行比对，确认读写正确性。
	3.通过多个文件的测试，确定编码译码的正确性；

三.正确性：
	
	1.检查逻辑与细节。
	2.linux下，对ANSI与UTF-8的文件，编码译码正常。
	  windows下，对字符较少的上述编码格式的文件，编码译码正常；字符较多时，则解码失败。原因不明，怀疑是 \r\n 的作用，但是找不出具体bug。

四.如何编译与正确运行：
	
	1.编译：g++ Huffman.cpp HuffmanNode.cpp Encoder.cpp -o Encode
		g++ Huffman.cpp HuffmanNode.cpp HuffmanDecoder.cpp Decoder.cpp -o Decoder
	
	2.运行：./Encoder ori.txt code.txt
		./Decoder code.txt tran.txt
	
五.个人吐槽：
	
	1.解码速度超慢，因为通过扫描数组进行解码，而不是遍历二叉树。
	  这限制于我一开始的想法，因为书里说，编码时保存霍夫曼编码。
	  所以我解码时比较懒就直接用数组的方式，而不是重建二叉数。

	2.因为上述的原因，所以编译小文件或者含有中文字符的文件时，
	  编码文件会大于源文件= =！因为附带的解码信息太冗长。
	  
	3.所以综上，文件较小时，编码效果差；文件较大时，解码速度慢。
	  所以这个程序基本没用。

六.查阅：

	位操作。
	fstream的相关内容。
	huffman算法。

七.声明：
	The work included in this program is all my own work.



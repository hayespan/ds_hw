解题思路：


    1.为节省内存，使用char型二维数组的临接矩阵表示所有站点之间的关系，如果两个站点之间可以直达则置为1，否则置为255（比

      较大的数）；


    2.新建known数组，parent数组，dist数组（char型）分别记录每个节点是否已被选择，父节点，当前最小“距离”；


    3.使用变形的dijksra算法，以节点是否可以直达为权，求出换乘最少的路径；


    4.因为每个节点可能有多个父节点，所以需用向量保存。


    当u节点对v节点进行松弛时，若使得v节点的最小距离 < 上一个值，则清空其父节点向量并加入u；若 == 时，将u压进向量中；


    5.终点弹出优先队列时，结束dijstra算法，得到以终点为根，以起点为叶子的树，其他节点为换乘点；


    6.进行树的前序遍历，每遍历一个点就push_front到list中，这样就得到所有不同换乘路径（换乘次数均为最小，只是换乘站点不

      一样）；


    7.因为路径中两点之间可能有多辆车，所以对于每两个相邻点u和v，都要搜索u到v的所有车次，并使用递归输出；


    8.因为要提高搜索两点间的车次的效率，所以一开始应该这样处理数据：


      (1)使用结构体line记录所有车次，每个line包含车次种类与上下行两条线路，使用map保存，以编号为key，以line*为值；


      (2)同时，为了方便操作，需对站点进行编号，并且line中的站点信息也是编号，使用辅助的set进行编号，每输入一个站点，如

         果在set中找到，则到站点名-编号map中直接获得编号，存进line中；如果没有找到，则加入set，以当前变量total++的值对

         其编号，在编号-站点名vector中保存，并且在站点名-编号map中保存，最后存进line中；


      (3)使用vector<pair<车次，上下行> >来保存每一站点所在所有路线，即为“站牌”，有利于提高搜索站点间所有车次的效率。



二、调试方法：


    写程序时，使用打印结果进行调试。现已进行了以下测试：


    1、各函数功能的实现；


    2、多次运行，对各种输入进行实例验证，观察输出结果。



三、算法正确性：


    1、程序可以正确地停止。在输入出错（无匹配项或者起始站与终点站一致）的情况下会提示重新输入，在没有该路径时会提示无法

       到达（程序允许存在非强连通的站点），不存在死循环（优先站点出队列直至终点站且所有站点只标志一次），在完成一次搜索

       之后可以选择退出或继续；


    2、换乘代价的取值是合理的。因为站点出队时，其“距离”属性便是从起始站到改站点的最少换乘数+1，因为数据中不存在多达254

       次的最小换乘，所以算法能求出正确结果。


    3、使用优先队列保证了需换乘多次的站点必须排在换乘少次的站点后出队。


    4、每次搜索都能将多条最少换乘路径记录下来。换乘次数相同的情况下，换乘站点可能不唯一；相临站点间，车次可能不唯一。没

       有遗漏。



四、如何使用：


    1.alllines.txt为数据文件，不可修改。


    2.因为编码问题所以提供dos和linux版本，自选。


    3.输入正确站点，可打印所有方案。如果结果方案数过多，建议直接输出到文本。



五、引用资源：


　　　http://stackoverflow.com/questions/649640/how-to-do-an-efficient-priority-update-in-stl-priority-queue



六、声明：

    The work included in this program is all our own work.



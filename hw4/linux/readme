程序的关键思路：
1.为节省内存，使用char型二维数组的临接矩阵表示所有站点之间的关系，如果两个站点之间可以直达则置为1，否则置为255（比较大的数）；
2.新建known数组，parent数组，dist数组分别记录每个节点是否已被选择，父节点，当前最小“距离”；
3.使用dijksra算法，以节点是否可以直达为权，求出换乘最少的路径；
4.因为每个节点可能有多个父节点，所以需用向量保存。
  当u节点对v节点进行松弛时，若使得v节点的最小距离 < 上一个值，则清空其父节点向量并加入u；若 == 时，将u压进向量中；
5.终点弹出优先队列时，结束dijstra算法，得到以终点为根，以起点为叶子的树，其他节点为换乘点；
6.进行树的前序遍历，每遍历一个点就push_front到list中，这样就得到所有不同换乘路径（换乘次数均为最小，只是换乘站点不一样）；
7.因为路径中两点之间可能有多辆车，所以对于每两个相邻点u和v，都要搜索u到v的所有车次，并使用递归输出；
8.因为要提高搜索两点间的车次的效率，所以一开始应该这样处理数据：
  (1)使用结构体line记录所有车次，每个line包含车次种类与上下行两条线路，使用map保存，以编号为key，以line*为值；
  (2)同时，为了方便操作，需对站点进行编号，并且line中的站点信息也是编号，使用辅助的set进行编号，每输入一个站点，如
     果在set中找到，则到站点名-编号map中直接获得编号，存进line中；如果没有找到，则加入set，以当前变量total++的值对
     其编号，在编号-站点名vector中保存，并且在站点名-编号map中保存，最后存进line中； 
  (3)使用vector来保存每一站点所在所有路线，即为“站牌”，有利于提高搜索站点间所有车次的效率；
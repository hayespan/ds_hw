一.如何解决问题：

  （1）类的确定：

	分析银行工作的整个过程：
		1银行开放
		2排队系统开放
		3每个单位时间内若干顾客进入队列
		4队列系统分析各个窗口工作状态
		5安排顾客接受窗口服务
		返回3进行循环直至银行即将关闭
		6排队系统关闭
		7处理未完成工作
		8银行关闭

	分析可知，排队系统需要接收顾客信息与窗口信息，所以可确定以下分类：
		QueueSystem  // 统筹工作，包含Window和Device类
		Window       // 服务窗口
		Device       // 叫号机
		Customer     // 顾客，本质是顾客属性包，而非顾客实体

  （2）程序流程：

	全程以变量I模拟时间进程；

	银行开门；
	排队系统初始化；
	每个时间单位下，生成符合泊松分布的顾客数量，触发QueueSystem入队操作；
	QueueSystem调用Device的触发入队按钮操作，即顾客进入相应模式的队列；
	QueueSystem查看Window工作状态；
		（实际上触发Window的“工作”操作，刷新工作状态）
	QueueSystem分配队列中的顾客进入空闲窗口；
	循环以上过程直到银行即将关闭；
	QueueSystem调用函数解散队列；
	QueueSystem检查Window状态，若仍在工作，则要求完成后再关闭Window；
	关闭QueueSystem；
	关闭银行；

  （3）功能拓展：
	提供模式选择：
		实时动态：可选择是否跟踪记录顾客动态；
		队列模式：可选择排队模式，单队列或多队列；

  （4）日志记录与命令行窗口的实时展示：
	使用fstream进行数据写入，生成DIALOG.txt；
	使用system()相关命令，打印实时动态；

二.如何测试：
	（1）通过打印结果和多个测试案列进行测试
	（2）通过FINAL DIALOG的数据统计，进行验证

三.正确性：
	（1）分析逻辑正确性
	（2）检查是否造成内存泄露从而导致错误

四.如何编译与正确运行：
	（1）编译：

		①windows下，若已配置g++环境变量，则直接运行目录下的
		  compile_run_win.bat
	     	若无，则可用集成环境新建工程，导入以下文件并编译即可：
		  Bank_QueueSystem_Simulation-win.cpp
		  RANDOM.cpp
		  RANDOM.H

		②linux下，直接运行compile_run_linux.sh

	（2）运行：

		依次输入：

		  开始时间（使用数字表示时刻，如 0 时刻，单位-分钟）

		  结束时间（使用数字表示时刻，如100时刻，单位-分钟）

		  服务窗口数量（建议输入合适数目，如5~10）

		  输入每分钟顾客入队的通常数量（泊松分布）（适当数目，5~10）

		  顾客办理业务时间最大值（适当数目，5~15）

		  选择排队方式（1为单队列，2为多队列）

		  是否跟踪顾客信息并记录日志中（1-是，0-否）

		  是否展示窗口实时动态（1-是，0-否，运行时间为(结束-开始)秒）

		运行中......

		运行结束，自动打开记录日志。

五.个人提醒：

	（1）输入数据应适当符合逻辑，不然太大的数据很可能跑不完。

	（2）日志最后有统计信息，完整包含原题目的要求数据。

	（3）记录跟踪顾客信息会产生大量数据，若不想具体细看，建议在运行时
	     选择不跟踪打印。

	（4）提供linux和windows版本原因在于调用system命令的不同，
	     同时吐槽一下，windows版本的实时动态真的是太卡顿了，
	     linux版本的实时动态输出效果很平滑。

	（5）时间不够，所以不做界面了。

六.查阅：
	google relevant usages of system() in different OS

七.声明：
	The work included in this program is all my own work.

